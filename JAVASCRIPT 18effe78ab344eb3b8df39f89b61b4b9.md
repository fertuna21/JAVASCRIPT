# JAVASCRIPT

J**avaScript basically used to add interactivity to website, to develop mobile apps, desktop applications, games.** JavaScript is a scripting or programming language that allows you to implement complex features on web pages — every time a web page does more than just sit there and display static information for you to look at — displaying timely content updates, interactive maps, animated 2D/3D graphics, scrolling video jukeboxes, etc. — you can bet that JavaScript is probably involved. It is the third layer of the layer cake of standard web technologies, two of which ([HTML](https://developer.mozilla.org/en-US/docs/Learn/HTML) and [CSS](https://developer.mozilla.org/en-US/docs/Learn/CSS)) we have covered in much more detail in other parts of the Learning Area.

**Console. Log ()** that is used to output a message to the web console. it can take multiple parameters separated by commas.

**Comments** as the name implies that is used to add comments. in js **// → comments**

*/ /* → multiple comments.

**Syntax** the structure of statements in a computer language. like others js has its own syntax.

**Adding JavaScript to a Web Page**

it can be added in three different ways.

1. **Inline Script**

Javacode

```html
!DOCTYPE html>
<html lang="en">
<head>
<title>30DaysOfScript:Inline Script</title>
</head>
<body>
<button onclick="alert('Welcome to 30DaysOfJavaScript!')">Click Me</button>
</body>
</html>
```

2 **Internal script**

**Java script**

```html
<!DOCTYPE html>
<html lang="en">
<head>
<title>30DaysOfScript:Internal Script</title>
<script>
console.log('Welcome to 30DaysOfJavaScript')
</script>
</head>
<body></body>
</html>
```

**3.External script**

**Javascript**

```html
<!DOCTYPE html>
<html lang="en">
<head>
<title>30DaysOfJavaScript:External script</title>
<script src="introduction.js"></script>
</head>
<body></body>
</html>
```

javascript

console.log('Welcome to 30DaysOfJavaScript')

we can use multi external scripts by giving two or more src link.

Data type is a type of data in java script.

some primitive data types : *String, Number, Boolean, undefined, Null*, and *Symbol*.

1.string :one or more char between two single or double quotes.

2.boolean :either true or false.

3 undefined : if u don’t assign a value to a variable.

1. Null is an empty value.

To check the data type of certain variable. we use the **typeof** operator

javascript

console.log(typeof 'Asabeneh') // string

console.log(typeof 5) // number

console.log(typeof true) // boolean

console.log(typeof null) // object type

console.log(typeof undefined) // undefined

Variables

Variables are *containers* of data. Variables are used to *store* data in a memory location. When a variable is declared, a memory location is reserved.

Syntax for declaring variable.

// Syntax **let nameOfVariable = value**

### Data Type

Data types can be classified in to two:

1. primitive data types
2. non primitive data types

Primitive data types in JS include

1. Numbers - Integers, floats
2. strings- any data under single quote, double quote or backtik quote
3. Strings - Any data under single quote, double quote or backtick quote
4. Booleans - true or false value
5. Null - empty value or no value
6. Undefined - a declared variable without a value
7. Symbol - A unique value that can be generated by Symbol constructor

***Primitive* data types** are immutable(non-modifiable) data types. Once a primitive data type is created we cannot modify it.

**let word = 'JavaScript’**

If we try to modify the string stored in variable *word*, JavaScript should raise an error.

***Non-primitive* data types** are modifiable or mutable. We can modify the value of non-primitive data types after it gets created.

array and object is an example of non primitive data type.

let nums = [1, 2, 3]

let numbers = [1, 2, 3]

console.log(nums == numbers)  // false

let userOne = {

name:'Asabeneh',

role:'teaching',

country:'Finland'

}

let userTwo = {

name:'Asabeneh',

role:'teaching',

country:'Finland'

}

console.log(userOne == userTwo) // false

**Math Object**

it is type of methods to work with numbers.

const PI = Math.PI

console.log(PI)                            // 3.141592653589793

// Rounding to the closest number
// if above .5 up if less 0.5 down rounding

console.log(Math.round(PI))                // 3 to round values to the nearest number

console.log(Math.round(9.81))              // 10

console.log(Math.floor(PI))                // 3 rounding down

console.log(Math.ceil(PI))                 // 4 rounding up

console.log(Math.min(-5, 3, 20, 4, 5, 10)) // -5, returns the minimum value

console.log(Math.max(-5, 3, 20, 4, 5, 10)) // 20, returns the maximum value

const randNum = Math.random() // creates random number between 0 to 0.999999
console.log(randNum)

// Let us  create random number between 0 to 10

const num = Math.floor(Math.random () * 11) // creates random number between 0 and 10
console.log(num)

//Absolute value
console.log(Math.abs(-10))      // 10

//Square root
console.log(Math.sqrt(100))     // 10

console.log(Math.sqrt(2))       // 1.4142135623730951

// Power
console.log(Math.pow(3, 2))     // 9

console.log(Math.E)             // 2.718

// Logarithm
// Returns the natural logarithm with base E of x, Math.log(x)
console.log(Math.log(2))        // 0.6931471805599453
console.log(Math.log(10))       // 2.302585092994046

// Returns the natural logarithm of 2 and 10 respectively
console.log(Math.LN2)           // 0.6931471805599453
console.log(Math.LN10)          // 2.302585092994046

// Trigonometry

Math.sin(0)

Math.sin(60)

Math.cos(0)

Math.cos(60)

**Random number generator**

**Javasrcer**

let randomNum = Math.random() // generates 0 to 0.999…

Strings

We can convert string to a number

we have three methods:

javascr

let num = '10'

let numInt = parseInt(num)

console.log(numInt) // 10

jaavascr

let num = '10'

let numInt = Number(num)

console.log(numInt) // 10

javascrp

let num = '10'

let numInt = +num

console.log(numInt) // 10

**String to Float**

converting string to float number.

Javascrr

let num = '9.81'

let numFloat = parseFloat(num)

console.log(numFloat) // 9.81

jacvascr

let num = '9.81'

let numFloat = Number(num)

console.log(numFloat) // 9.81

javascr

let num = '9.81'

let numFloat = +num

console.log(numFloat) // 9.81

**Float to int**

converting float to integer.

Javascree
let num = 9.81
let numInt = parseInt(num)

console.log(numInt) // 9

# JavaScript Loops

Loops are handy, if you want to run the same code over and over again, each time with a different value.

Often this is the case when working with arrays:

# Instead of writing:

text += cars[0] + "<br>";text += cars[1] + "<br>";text += cars[2] + "<br>";text += cars[3] + "<br>";text += cars[4] + "<br>";text += cars[5] + "<br>";

# You can write:

for (let i = 0; i < cars.length; i++) {  text += cars[i] + "<br>";}

---

# Different Kinds of Loops

JavaScript supports different kinds of loops:

- `for` - loops through a block of code a number of times
- `for/in` - loops through the properties of an object
- `for/of` - loops through the values of an iterable object
- `while` - loops through a block of code while a specified condition is true
- `do/while` - also loops through a block of code while a specified condition is true

---

# The For Loop

A `[for](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for)` loop repeats until a specified condition evaluates to false. The JavaScript `for` loop is similar to the Java and C `for` loop

The `for` statement creates a loop with 3 optional expressions:

for (*expression 1*; *expression 2*; *expression 3*) {  // *code block to be executed*}

1. The initializing expression `initialization`, if any, is executed. This expression usually initializes one or more loop counters, but the syntax allows an expression of any degree of complexity. This expression can also declare variables.
2. The `condition` expression is evaluated. If the value of `condition` is true, the loop statements execute. Otherwise, the `for` loop terminates. (If the `condition` expression is omitted entirely, the condition is assumed to be true.)
3. The `statement` executes. To execute multiple statements, use a [block statement](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block) (`{ }`) to group those statements.
4. If present, the update expression `afterthought` is executed.
5. Control returns to Step 2.

```jsx
function countSelected(selectObject) {
    let numberSelected = 0;
    for (let i = 0; i < selectObject.options.length; i++) {
      if (selectObject.options[i].selected) {
        numberSelected++;
      }
    }
    return numberSelected;
  }
  
  const btn = document.getElementById("btn");
  
  btn.addEventListener("click", () => {
    const musicTypes = document.selectForm.musicTypes;
    console.log(`You have selected ${countSelected(musicTypes)} option(s).`);
  });
```

# The For Of Loop

The JavaScript `for of` statement loops through the values of an iterable object. The `[for...of](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of)` statement creates a loop Iterating over [iterable objects](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols) (including `[Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)`, `[Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)`, `[Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set)`, `[arguments](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments)` object and so on), invoking a custom iteration hook with statements to be executed for the value of each distinct property.

It lets you loop over iterable data structures such as Arrays, Strings, Maps, NodeLists, and more:

# Syntax

for (variable of iterable) {  // *code block to be executed*}

```jsx
const arr = [3, 5, 7];
arr.foo = "hello";

for (const i in arr) {
  console.log(i);
}
// "0" "1" "2" "foo"

for (const i of arr) {
  console.log(i);
}
// Logs: 3 5 7
```

# The For In Loop

The `[for...in](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in)` statement iterates a specified variable over all the enumerable properties of an object. For each distinct property, JavaScript executes the specified statements.

The JavaScript `for in` statement loops through the properties of an Object:

# Syntax

for (key in object) {  // *code block to be executed*}

```jsx
function dumpProps(obj, objName) {
    let result = "";
    for (const i in obj) {
      result += `${objName}.${i} = ${obj[i]}<br>`;
    }
    result += "<hr>";
    return result;
  }
```

# The While Loop

The `while` loop loops through a block of code as long as a specified condition is true. 

If the `condition` becomes `false`, `statement` within the loop stops executing and control passes to the statement following the loop.

The condition test occurs *before* `statement` in the loop is executed. If the condition returns `true`, `statement` is executed and the `condition` is tested again. If the condition returns `false`, execution stops, and control is passed to the statement following `while`.

To execute multiple statements, use a block statement (`{ }`) to group those statements.

```jsx
// Infinite loops are bad!
while (true) {
  console.log("Hello, world!");
}
```

# Syntax

while (*condition*) {  *// code block to be executed*}

# JavaScript Arrays

The **`Array`** object, as with arrays in other programming languages, enables [storing a collection of multiple items under a single variable name](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps/Arrays), and has members for [performing common array operations](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#examples).

An array is a special variable, which can hold more than one value:

const cars = ["Saab", "Volvo", "BMW"];

```jsx
fruits[5] = "mango";
console.log(fruits[5]); // 'mango'
console.log(Object.keys(fruits)); // ['0', '1', '2', '5']
console.log(fruits.length); // 6
```

# Why Use Arrays?

If you have a list of items (a list of car names, for example), storing the cars in single variables could look like this:

let car1 = "Saab";let car2 = "Volvo";let car3 = "BMW";

However, what if you want to loop through the cars and find a specific one? And what if you had not 3 cars, but 300?

The solution is an array!

An array can hold many values under a single name, and you can access the values by referring to an index number.

---

# Creating an Array

Using an array literal is the easiest way to create a JavaScript Array.

Syntax:

const *array_name* = [*item1*, *item2*, ...];

 

In JavaScript, arrays aren't [primitives](https://developer.mozilla.org/en-US/docs/Glossary/Primitive) but are instead `Array` objects with the following core characteristics:

- **JavaScript arrays are resizable** and **can contain a mix of different [data types](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures)**. (When those characteristics are undesirable, use [typed arrays](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Typed_arrays) instead.)
- **JavaScript arrays are not associative arrays** and so, array elements cannot be accessed using arbitrary strings as indexes, but must be accessed using nonnegative integers (or their respective string form) as indexes.
- **JavaScript arrays are [zero-indexed](https://en.wikipedia.org/wiki/Zero-based_numbering)**: the first element of an array is at index `0`, the second is at index `1`, and so on — and the last element is at the value of the array's `[length](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/length)` property minus `1`.
- **JavaScript [array-copy operations](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#copy_an_array) create [shallow copies](https://developer.mozilla.org/en-US/docs/Glossary/Shallow_copy)**. (All standard built-in copy operations with *any* JavaScript objects create shallow copies, rather than [deep copies](https://developer.mozilla.org/en-US/docs/Glossary/Deep_copy)).

```jsx
fruits.length = 10;
console.log(fruits); // ['banana', 'apple', 'peach', empty x 2, 'mango', empty x 4]
console.log(Object.keys(fruits)); // ['0', '1', '2', '5']
console.log(fruits.length); // 10
console.log(fruits[8]); // undefined
```

```jsx
const colors = ["red", "yellow", "blue"];
colors[5] = "purple";
colors.forEach((item, index) => {
  console.log(`${index}: ${item}`);
});
// Output:
// 0: red
// 1: yellow
// 2: blue
// 5: purple

colors.reverse(); // ['purple', empty × 2, 'blue', 'yellow', 'red']
```

colors.reverse(); // ['purple', empty × 2, 'blue', 'yellow', 'red']

# JavaScript Array Methods

# Basic Array Methods

| https://www.w3schools.com/js/js_array_methods.asp#mark_lengthhttps://www.w3schools.com/js/js_array_methods.asp#mark_tostring()https://www.w3schools.com/js/js_array_methods.asp#mark_athttps://www.w3schools.com/js/js_array_methods.asp#mark_joinhttps://www.w3schools.com/js/js_array_methods.asp#mark_pophttps://www.w3schools.com/js/js_array_methods.asp#mark_push
Se Also:https://www.w3schools.com/js/js_array_search.asphttps://www.w3schools.com/js/js_array_sort.asphttps://www.w3schools.com/js/js_array_iteration.asp | https://www.w3schools.com/js/js_array_methods.asp#mark_shifthttps://www.w3schools.com/js/js_array_methods.asp#mark_unshifthttps://www.w3schools.com/js/js_array_methods.asp#mark_deletehttps://www.w3schools.com/js/js_array_methods.asp#mark_concathttps://www.w3schools.com/js/js_array_methods.asp#mark_flathttps://www.w3schools.com/js/js_array_methods.asp#mark_splicehttps://www.w3schools.com/js/js_array_methods.asp#mark_tosplicedhttps://www.w3schools.com/js/js_array_methods.asp#mark_slice |
| --- | --- |

---

```jsx
const colors = ["red", "yellow", "blue"];
colors[5] = "purple";
const iterator = colors.keys();
for (const key of iterator) {
  console.log(`${key}: ${colors[key]}`);
}
// Output
// 0: red
// 1: yellow
// 2: blue
// 3: undefined
// 4: undefined
// 5: purple

const newColors = colors.toReversed(); // ['purple', undefined, undefined, 'blue', 'yellow', 'red']
```

# JavaScript Array length

The `length` property returns the length (size) of an array:

# Example

const fruits = ["Banana", "Orange", "Apple", "Mango"];let size = fruits.length;

---

# JavaScript Array toString()

The JavaScript method `toString()` converts an array to a string of (comma separated) array values.

# Example

const fruits = ["Banana", "Orange", "Apple", "Mango"];document.getElementById("demo").innerHTML = fruits.toString();

# JavaScript Functions

A JavaScript function is a block of code designed to perform a particular task.

A JavaScript function is executed when "something" invokes it (calls it).

# Example

// Function to compute the product of p1 and p2function myFunction(p1, p2) {  return p1 * p2;}

---

# JavaScript Function Syntax

A JavaScript function is defined with the `function` keyword, followed by a **name**, followed by parentheses **()**.

Function names can contain letters, digits, underscores, and dollar signs (same rules as variables).

The parentheses may include parameter names separated by commas:

**(*parameter1, parameter2, ...*)**

The code to be executed, by the function, is placed inside curly brackets: **{}**

function *name*(*parameter1, parameter2, parameter3*) {  // *code to be executed*}

Function **parameters** are listed inside the parentheses () in the function definition.

Function **arguments** are the **values** received by the function when it is invoked.

Inside the function, the arguments (the parameters) behave as local variables.

```jsx
function myFunc(theObject) {
  theObject.make = "Toyota";
}

const mycar = {
  make: "Honda",
  model: "Accord",
  year: 1998,
};

console.log(mycar.make); // "Honda"
myFunc(mycar);
console.log(mycar.make); // "Toyota"
```

---

# Function Invocation

The code inside the function will execute when "something" **invokes** (calls) the function:

- When an event occurs (when a user clicks a button)
- When it is invoked (called) from JavaScript code
- Automatically (self invoked)

You will learn a lot more about function invocation later in this tutorial.

```jsx
function myFunc(theArr) {
  theArr[0] = 30;
}

const arr = [45];

console.log(arr[0]); // 45
myFunc(arr);
console.log(arr[0]); // 30
```

---

---

# Function Return

When JavaScript reaches a `return` statement, the function will stop executing.

If the function was invoked from a statement, JavaScript will "return" to execute the code after the invoking statement.

Functions often compute a **return value**. The return value is "returned" back to the "caller":

```jsx
function map(f, a) {
  const result = new Array(a.length);
  for (let i = 0; i < a.length; i++) {
    result[i] = f(a[i]);
  }
  return result;
}

const cube = function (x) {
  return x * x * x;
};

const numbers = [0, 1, 2, 5, 10];
console.log(map(cube, numbers)); // [0, 1, 8, 125, 1000]
```

# Example

Calculate the product of two numbers, and return the result:

// Function is called, the return value will end up in xlet x = myFunction(4, 3);function myFunction(a, b) {// Function returns the product of a and b  return a * b;}

OBJECTS

JavaScript is designed on a simple object-based paradigm. An object is a collection of [properties](https://developer.mozilla.org/en-US/docs/Glossary/Property/JavaScript), and a property is an association between a name (or *key*) and a value. A property's value can be a function, in which case the property is known as a [method](https://developer.mozilla.org/en-US/docs/Glossary/Method).

Objects in JavaScript, just as in many other programming languages, can be compared to objects in real life. In JavaScript, an object is a standalone entity, with properties and type. Compare it with a cup, for example. A cup is an object, with properties. A cup has a color, a design, weight, a material it is made of, etc. The same way, JavaScript objects can have properties, which define their characteristics.

In addition to objects that are predefined in the browser, you can define your own objects. This chapter describes how to use objects, properties, and methods, and how to create your own objects.

## [Creating new objects](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_objects#creating_new_objects)

You can create an object using an [object initializer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer). Alternatively, you can first create a constructor function and then instantiate an object by invoking that function with the `new` operator.

### [Using object initializers](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_objects#using_object_initializers)

Object initializers are also called *object literals*. "Object initializer" is consistent with the terminology used by C++.

The syntax for an object using an object initializer is:

JSCopy to Clipboard

```jsx
const obj = {
  property1: value1, // property name may be an identifier
  2: value2, // or a number
  "property n": value3, // or a string
};
```

Java Strings
Strings are used for storing text.
A String variable contains a collection of characters surrounded by double quotes:
String greeting = "Hello";
String Methods
There are many string methods available, for String txt = "Hello World";

```jsx
System.out.println(txt.toUpperCase());   // Outputs "HELLO WORLD"
System.out.println(txt.toLowerCase());   // Outputs "hello world"
 toUpperCase() and toLowerCase():
```

Character in a String

The indexOf() method returns the **index** (the position) of the first occurrence of a specified text in a string (including whitespace):

```jsx
String txt = "Please locate where 'locate' occurs!";
System.out.println(txt.indexOf("locate")); // Outputs 7
```

**Java Strings**

Strings are used for storing text.

Create a variable of type String and assign it a value:

String greeting = "Hello";

**String Length**

A String in Java is actually an object, which contain methods that can perform certain operations on strings. For example, the length of a string can be found with the length() method:

```jsx
String txt = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";System.out.println("The length of the txt string is: " + txt.length());
```

# **Java String Concatenation**

## String Concatenation

The + operator can be used between strings to combine them. This is called

**concatenation**

```jsx
String firstName = "John";
String lastName = "Doe";
System.out.println(firstName + " " + lastName);
```

# **Java Numbers and Strings**

If you add two numbers, the result will be a number:

```jsx
int x = 10;
int y = 20;
int z = x + y;  // z will be 30 (an integer/number)
```

Strings - Special Characters

Because strings must be written within quotes, Java will misunderstand this string, and generate an error:

String txt = "We are the so-called "Vikings" from the north.";

The solution to avoid this problem, is to use the **backslash escape character**.

The backslash (\) escape character turns special characters into string characters:

| Escape character | Result | Description |
| --- | --- | --- |

| \' | ' | Single quote |
| --- | --- | --- |
| \" | " | Double quote |
| \\ | \ | Backslash |

The sequence \"  inserts a double quote in a string:

```jsx
String txt = "We are the so-called \"Vikings\" from the north.";
```

**Boolean**

represents either true or false.

let isLightOn = true

let isRaining = false

let isHungry = false

let isMarried = true

let truValue = 4 > 3    // true

let falseValue = 4 < 3  // false

**Undefined**

let firstName

console.log(firstName) //not defined, because it is not assigned to a value yet

Null

let empty = null

console.log(empty) // -> null , means no value

**operators**

**Assignment operators**

equal sign is an assignment operator

let firstName = 'Asabeneh'

let country = 'Finland'

**Arithmetic Operators**

Addition(+): a + b

Subtraction(-): a - b

Multiplication(*): a * b

Division(/): a / b

Modulus(%): a % b

Exponential(**): a ** b

let numOne = 4

let numTwo = 3

let sum = numOne + numTwo

let diff = numOne - numTwo

let mult = numOne * numTwo

let div = numOne / numTwo

let remainder = numOne % numTwo

let powerOf = numOne ** numTwo

console.log(sum, diff, mult, div, remainder, powerOf) // 7,1,12,1.33,1, 64

**Logical Operators**

// && ampersand operator example

const check = 4 > 3 && 10 > 5         // true && true -> true

const check = 4 > 3 && 10 < 5         // true && false -> false

const check = 4 < 3 && 10 < 5         // false && false -> false

// || pipe or operator, example

const check = 4 > 3 || 10 > 5         // true  || true -> true

const check = 4 > 3 || 10 < 5         // true  || false -> true

const check = 4 < 3 || 10 < 5         // false || false -> false

//! Negation examples

let check = 4 > 3                     // true

let check = !(4 > 3)                  //  false

let isLightOn = true

let isLightOff = !isLightOn           // false

let isMarried = !false                // true

**Increment Operator and Decrement Operator**

Increment could be pre or post increment.

1. pre-increment and pre-decrement

let count = 0

console.log(++count)        // 1

console.log(count)          // 1

let count = 0

console.log(--count) // -1

console.log(count)  // -1

1. post-increment and post-decrement

let count = 0

console.log(count++)        // 0

console.log(count)          // 1

let count = 0

console.log(count--) // 0

console.log(count)   // -1

### Ternary Operators

allows to write a condition.

0let isRaining = true

isRaining

? console.log('You need a rain coat.')

: console.log('No need for a rain coat.')

isRaining = false

isRaining

? console.log('You need a rain coat.')

: console.log('No need for a rain coat.')

You need a rain coat.

No need for a rain coat.

**Date Object**

**Creating a time object.**

const now = new Date()

console.log(now) // Sat Jan 04 2020 00:56:41 GMT+0200 (Eastern European Standard Time)

**Getting Full year**

const now = new Date()

console.log(now.getFullYear()) // 2020

**Getting month**

const now = new Date()

console.log(now.getMonth()) // 0, because the month is January,  month(0-11)

Getting date

const now = new Date()

console.log(now.getDate()) // 4, because the day of the month is 4th,  day(1-31)

**Getting day**

const now = new Date()

console.log(now.getDay()) // 6, because the day is Saturday which is the 7th day

//  Sunday is 0, Monday is 1 and Saturday is 6

// Getting the weekday as a number (0-6)

Getting hours

const now = new Date()

console.log(now.getHours()) // 0, because the time is 00:56:41

## Day-4

### Conditionals

are used for make decisions based on different conditions.

T**wo ways of conditionals.**

1. Conditional execution a block of one or more statements will be executed if a certain expression is true

 2. Repetitive execution a block of one or more statements will be repetitively executed as long as a certain expression is true.

# switch

The **`switch`** statement evaluates an [expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_operators), matching the expression's value against a series of `case` clauses, and executes [statements](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements) after the first `case` clause with a matching value, until a `break` statement is encountered. The `default` clause of a `switch` statement will be jumped to if no `case` matches the expression's value.

**Switch**

alternative for if else if else else

switch(caseValue){

case 1:

// code

break

case 2:

// code

**If Else if else**

// syntax

if (condition) {

// code

} else if (condition) {

// code

} else {

//  code

}

# **What is a Higher Order Function?**

A higher order function is a function that takes one or more functions as arguments, or returns a function as its result.

There are several different types of higher order functions like map and reduce.

```jsx
// Callback function, passed as a parameter in the higher order function
function callbackFunction(){
    console.log('I am  a callback function');
}

// higher order function
function higherOrderFunction(func){
    console.log('I am higher order function')
    func()
}

higherOrderFunction(callbackFunction);
```

# **How to Use Higher Order Functions**

You can use higher order functions in a variety of ways.

When working with arrays, you can use the `map()`, `reduce()`, `filter()`, and `sort()` functions to manipulate and transform data in an array.

When working with objects, you can use the `Object.entries()` function to create a new array from an object.

When working with functions, you can use the `compose()` function to create complex functions from simpler ones.

# **How to Use Some Important Higher Order Functions**

There are various built in HOFs, and some of the most common ones are map(), filter() and reduce(). So let's understand each one of these in detail.

### **How to use `map()` in JavaScript**

The `map()` function takes an array of values and applies a transformation to each value in the array. It does not mutate the original array. It is often used to transform an array of data into a new array with a different structure.

Let's understand with the help of examples.

**Example 1**: Suppose we want to add 10 to every element in a array. We can use the `map()` method to map over every element in the array to add 10 to it.

```jsx
const arr = [1, 2, 3, 4, 5];
const output = arr.map((num) => num += 10)
console.log(arr); // [1, 2, 3, 4, 5]
console.log(output); // [11, 12, 13, 14, 15]
```

**Working with JSON**

JavaScript Object Notation (JSON) is a standard text-based format for representing structured data based on JavaScript object syntax. It is commonly used for transmitting data in web applications (e.g., sending some data from the server to the client, so it can be displayed on a web page, or vice versa). You'll come across it quite often, so in this article, we give you all you need to work with JSON using JavaScript, including parsing JSON so you can access data within it, and creating JSON.

[JSON](https://developer.mozilla.org/en-US/docs/Glossary/JSON) is a text-based data format following JavaScript object syntax, which was popularized by [Douglas Crockford](https://en.wikipedia.org/wiki/Douglas_Crockford). Even though it closely resembles JavaScript object literal syntax, it can be used independently from JavaScript, and many programming environments feature the ability to read (parse) and generate JSON.

JSON exists as a string — useful when you want to transmit data across a network. It needs to be converted to a native JavaScript object when you want to access the data. This is not a big issue — JavaScript provides a global [JSON](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON) object that has methods available for converting between the two.

### [JSON structure](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/JSON#json_structure)

As described above, JSON is a string whose format very much resembles JavaScript object literal format. You can include the same basic data types inside JSON as you can in a standard JavaScript object — strings, numbers, arrays, booleans, and other object literals. This allows you to construct a data hierarchy, like so:

```jsx
{
  "squadName": "Super hero squad",
  "homeTown": "Metro City",
  "formed": 2016,
  "secretBase": "Super tower",
  "active": true,
  "members": [
    {
      "name": "Molecule Man",
      "age": 29,
      "secretIdentity": "Dan Jukes",
      "powers": ["Radiation resistance", "Turning tiny", "Radiation blast"]
    },
    {
      "name": "Madame Uppercut",
      "age": 39,
      "secretIdentity": "Jane Wilson",
      "powers": [
        "Million tonne punch",
        "Damage resistance",
        "Superhuman reflexes"
      ]
    },
    {
      "name": "Eternal Flame",
      "age": 1000000,
      "secretIdentity": "Unknown",
      "powers": [
        "Immortality",
        "Heat Immunity",
        "Inferno",
        "Teleportation",
        "Interdimensional travel"
      ]
    }
  ]
}
```

### [Other notes](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/JSON#other_notes)

- JSON is purely a string with a specified data format — it contains only properties, no methods.
- JSON requires double quotes to be used around strings and property names. Single quotes are not valid other than surrounding the entire JSON string.
- Even a single misplaced comma or colon can cause a JSON file to go wrong, and not work. You should be careful to validate any data you are attempting to use (although computer-generated JSON is less likely to include errors, as long as the generator program is working correctly). You can validate JSON using an application like [JSONLint](https://jsonlint.com/).
- JSON can actually take the form of any data type that is valid for inclusion inside JSON, not just arrays or objects. So for example, a single string or number would be valid JSON.
- Unlike in JavaScript code in which object properties may be unquoted, in JSON only quoted strings may be used as properties.

# Promise

The **`Promise`** object represents the eventual completion (or failure) of an asynchronous operation and its resulting value.

## [Description](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise#description)

 **`Promise`** is a proxy for a value not necessarily known when the promise is created. It allows you to associate handlers with an asynchronous action's eventual success value or failure reason. This lets asynchronous methods return values like synchronous methods: instead of immediately returning the final value, the asynchronous method returns a *promise* to supply the value at some point in the future.

A `Promise` is in one of these states:

- *pending*: initial state, neither fulfilled nor rejected.
- *fulfilled*: meaning that the operation was completed successfully.
- *rejected*: meaning that the operation failed.

The *eventual state* of a pending promise can either be *fulfilled* with a value or *rejected* with a reason (error). When either of these options occur, the associated handlers queued up by a promise's `then` method are called. If the promise has already been fulfilled or rejected when a corresponding handler is attached, the handler will be called, so there is no race condition between an asynchronous operation completing and its handlers being attached.

A promise is said to be *settled* if it is either fulfilled or rejected, but not pending.

```jsx
new Promise((resolveOuter) => {
  resolveOuter(
    new Promise((resolveInner) => {
      setTimeout(resolveInner, 1000);
    }),
  );
});
```

# Set vs Map in JavaScript

In **[JavaScript](https://www.geeksforgeeks.org/javascript/)**, **[Set](https://www.geeksforgeeks.org/sets-in-javascript/)** and **[Map](https://www.geeksforgeeks.org/map-in-javascript/)** are two types of objects that are used for storing data in an ordered manner. Both these data structures are used to store distinct types of data inside the same object. In Maps, the data is stored as a key-value pair whereas in Set data is a single collection of values that are unique.

# JavaScript Set

It is a collection of values that can be accessed without a specific key. The elements are unique and the addition of duplicates is not allowed. Sets are mostly used to remove duplicates from any other data structure

```jsx
let sample = new Set();
sample.add("Hello");
sample.add(1)
sample.add("Bye")
sample.add("@");

for (let item of sample) {
	console.log(item);
	}
```

# JavaScript Map

Maps are used to store data in key-value pairs where keys are used to uniquely identify an element and values contain the data associated with it.

```jsx
let sample = new Map();
sample.set("name", "Ram");
sample.set("Role", "SDE")
sample.set("Country", "India")

for (let item of sample) {
	console.log(item);
	}
```

# Difference between Map and set

| Map | Set |
| --- | --- |
| It is a collection of key-value | It is a collection of unique elements |
| Map is two-dimensional | The set is one dimensional |
| Values are accessed using keys | In-built methods are used to access  values |

**Understanding Destructuring and Spread Syntax**

# **Destructuring**

Destructuring assignment allows assigning the properties of an Array or Object to multiple variables at once. There are two types of restructuring; **object destructuring** and **array destructuring**.

## **Object Destructuring**

Object destructuring binds variables to different properties of an object. Let’s have a look at an object with the traditional approach to creating variables and assign values to them.

Destructuring Assignment is a JavaScript expression that allows to **unpack values** from arrays, or properties from objects, into distinct variables data can be extracted from *arrays, objects, nested objects* and **assigning to variables**. In Destructuring Assignment on the left-hand side defined that which value should be unpacked from the sourced variable. In general way implementation of the *extraction* of the array is as shown below:

```jsx
<script> 
var names = ["alpha", "beta", "gamma", "delta"]; 

var firstName = names[0]; 
var secondName = names[1]; 

console.log(firstName);//"alpha" 
console.log(secondName);//"beta" 
</script>
```

# JavaScript Spread Operator

**The Spread operator** allows an iterable to expand in places where 0+ arguments are expected. It is mostly used in the variable array where there is more than 1 value is expected. It allows us the privilege to obtain a list of parameters from an array.

The syntax of the Spread operator is the same as the **[Rest parameter](https://www.geeksforgeeks.org/javascript-rest-operator/)** but it works opposite of it.

```jsx
// spread operator doing the concat job
let arr = [1, 2, 3];
let arr2 = [4, 5];

arr = [...arr, ...arr2];
console.log(arr); // [ 1, 2, 3, 4, 5 ]
```

**Note**: Though we can achieve the same result as the concat method, it is not recommended to use the spread in this particular case, as for a large data set it will work slower when compared to the native **[concat() method](https://www.geeksforgeeks.org/javascript-string-prototype-concat-function/)**.

```jsx
// changed the original array
let arr = ['a', 'b', 'c'];
let arr2 = arr;

arr2.push('d');

console.log(arr2);
console.log(arr); 
//even affected the original array(arr)
```

**Regular Expressions**

A regular expression or RegExp is a small programming language that helps to find pattern in data. A RegExp can be used to check if some pattern exists in a different data types. To use RegExp in JavaScript either we use RegExp constructor or we can declare a RegExp pattern using two forward slashes followed by a flag. We can create a pattern in two ways.

To declare a string we use a single quote, double quote a backtick to declare a regular expression we use two forward slashes and an optional flag. The flag could be g, i, m, s, u or y.

### RegExp parameters

A regular expression takes two parameters. One required search pattern and an optional flag.

### Pattern

A pattern could be a text or any form of pattern which some sort of similarity. For instance the word spam in an email could be a pattern we are interested to look for in an email or a phone number format number might be our interest to look for.

### Flags

Flags are optional parameters in a regular expression which determine the type of searching. Let us see some of the flags:

- g: a global flag which means looking for a pattern in whole text
- i: case insensitive flag(it searches for both lowercase and uppercase)
- m: multiline

### Creating a pattern with RegExp Constructor

Declaring regular expression without global flag and case insensitive flag.

```jsx
// without flag
let pattern = 'love'
let regEx = new RegExp(pattern)
```

Declaring regular expression with global flag and case insensitive flag.

```jsx
let pattern = 'love'
let flag = 'gi'
let regEx = new RegExp(pattern, flag)
```

Declaring a regex pattern using RegExp object. Writing the pattern and the flag inside the RegExp constructor

```jsx
let regEx = new RegExp('love','gi')
```

### **Console Object in JavaScript:**

The **`console`** object in JavaScript provides a set of methods to interact with the debugging console of the browser or the Node.js environment. These methods allow developers to output various types of information, such as log messages, warnings, errors, and performance metrics, to the console for debugging and monitoring purposes.

### Common Console Methods:

1. **console.log()**: Prints a message to the console.

```jsx
console.log('Hello, world!');
```

**console.error()**: Outputs an error message to the console.

```jsx
console.error('An error occurred!');
```

**console.warn()**: Outputs a warning message to the console.

```jsx
console.warn('This is a warning!');
```

**console.info()**: Outputs an informational message to the console.

```jsx
console.info('This is an informational message.');
```

**console.table()**: Displays tabular data as a table.

```jsx
const data = [
  { name: 'John', age: 30 },
  { name: 'Jane', age: 25 }
];
console.table(data);
```

**console.group() / console.groupEnd()**: Groups related log messages together.

```jsx
console.group('Group 1');
console.log('Message 1');
console.log('Message 2');
console.groupEnd();
```

### **Error Handling in JavaScript:**

Error handling in JavaScript involves managing and responding to errors that occur during the execution of a program. This is crucial for debugging and ensuring robustness in applications.

### Try...Catch Statement:

The **`try...catch`** statement allows you to handle exceptions (errors) that occur within a block of code.

```jsx
try {
  // Code that may throw an error
  throw new Error('Something went wrong!');
} catch (error) {
  // Handle the error
  console.error(error.message);
}
```

### Error Types:

JavaScript provides various built-in error types, such as **`Error`**, **`SyntaxError`**, **`TypeError`**, **`ReferenceError`**, etc. You can catch specific error types using multiple **`catch`** blocks.

```jsx
try {
  // Code that may throw an error
  someFunction();
} catch (error) {
  if (error instanceof ReferenceError) {
    console.error('ReferenceError:', error.message);
  } else if (error instanceof TypeError) {
    console.error('TypeError:', error.message);
  } else {
    console.error('Error:', error.message);
  }
}
```

### **Classes in JavaScript:**

ES6 introduced a more convenient syntax for creating objects and dealing with inheritance using classes.

### Class Declaration:

```jsx
class Animal {
  constructor(name) {
    this.name = name;
  }

  speak() {
    console.log(this.name + ' makes a noise.');
  }
}

const animal = new Animal('Generic');
animal.speak(); // Output: Generic makes a noise.
```

**Class Inheritance:**

```jsx
class Dog extends Animal {
  constructor(name, breed) {
    super(name);
    this.breed = breed;
  }

  speak() {
    console.log(this.name + ' barks.');
  }
}

const dog = new Dog('Buddy', 'Labrador');
dog.speak(); // Output: Buddy barks.
```

Classes provide a cleaner and more concise syntax for creating objects and implementing inheritance in JavaScript, making code more readable and maintainable.

### **Web Storage in JavaScript:**

Web storage is a mechanism that allows web applications to store data locally within the user's browser. It provides a way to persistently store key-value pairs of data in a more efficient and secure manner than cookies. There are two main types of web storage available in modern web browsers: **localStorage** and **sessionStorage**.

### 1. localStorage:

The **`localStorage`** object allows developers to store data with no expiration date. This means the data will persist even after the browser is closed and reopened.

```jsx
// Storing data in localStorage
localStorage.setItem('username', 'John');

// Retrieving data from localStorage
const username = localStorage.getItem('username');
console.log('Username:', username); // Output: Username: John

// Removing data from localStorage
localStorage.removeItem('username');
```

### 2. sessionStorage:

The **`sessionStorage`** object stores data only for the duration of the page session. Once the browser tab or window is closed, the data is deleted.

```jsx
// Storing data in sessionStorage
sessionStorage.setItem('theme', 'dark');

// Retrieving data from sessionStorage
const theme = sessionStorage.getItem('theme');
console.log('Theme:', theme); // Output: Theme: dark

// Removing data from sessionStorage
sessionStorage.removeItem('theme');
```

### **Usage and Considerations:**

1. **Data Limitations**: Both **`localStorage`** and **`sessionStorage`** have storage limits (typically 5-10MB) per origin (domain and protocol). Exceeding this limit may result in a "QuotaExceededError".
2. **Security**: Data stored in web storage is scoped to the origin of the website, meaning data stored by one website cannot be accessed by another website.
3. **Data Persistence**: Unlike cookies, data stored in web storage is not transmitted with every HTTP request, reducing overhead and improving performance.
4. **Data Format**: Web storage stores data as strings. To store complex data types like objects and arrays, you'll need to serialize and deserialize them using **`JSON.stringify()`** and **`JSON.parse()`**.

```jsx
// Storing an object in localStorage
const user = {
  name: 'Alice',
  age: 30
};
localStorage.setItem('user', JSON.stringify(user));

// Retrieving and parsing the object from localStorage
const storedUser = JSON.parse(localStorage.getItem('user'));
console.log('User:', storedUser); // Output: User: { name: 'Alice', age: 30 }
```

1. **Browser Support**: Web storage is widely supported across modern web browsers, including Chrome, Firefox, Safari, and Edge. However, it's essential to handle scenarios where web storage may not be available, such as in older browsers or in environments where it's explicitly disabled.

In summary, web storage in JavaScript provides a convenient way to store and retrieve data locally within the browser, offering benefits in terms of performance, security, and ease of use for web developers building modern web applications.

### **Understanding Closures in JavaScript:**

Closures are a fundamental concept in JavaScript, integral to understanding the language's behavior, especially when dealing with functions and scope. A closure is created when a function is defined within another function and has access to its parent function's variables. This access persists even after the parent function has finished executing.

### How Closures Work:

1. **Lexical Scoping**: JavaScript uses lexical scoping, which means that the scope of variables is determined by their position within the code. When a function is defined within another function, it retains access to the variables in the outer function's scope, even after the outer function has completed execution.
2. **Access to Outer Scope Variables**: Closures have access to variables in their outer scope, including the outer function's parameters and variables, as well as global variables. This access allows closures to "remember" and manipulate the values of these variables.
3. **Encapsulation**: Closures encapsulate their own scope, preserving the state of variables within that scope. This encapsulation enables data privacy and helps prevent variable pollution in the global scope.

### Example of Closures in JavaScript:

```jsx
function outerFunction() {
  let outerVariable = 'I am from the outer function';

  function innerFunction() {
    console.log(outerVariable); // Accessing outerVariable from the outer scope
  }

  return innerFunction;
}

const closureExample = outerFunction();
closureExample(); // Output: I am from the outer function
```

In this example:

- The **`outerFunction`** defines a local variable **`outerVariable`** and declares an **`innerFunction`** inside it.
- The **`innerFunction`** has access to the **`outerVariable`** due to closure, even though **`outerFunction`** has finished executing.
- When **`outerFunction`** is called and returns **`innerFunction`**, it creates a closure that retains access to **`outerVariable`**.
- Calling **`closureExample()`** later still allows **`innerFunction`** to access and log the value of **`outerVariable`**.

### Use Cases for Closures:

1. **Data Privacy**: Closures enable the creation of private variables and functions, accessible only within the scope of a particular function, enhancing data security and preventing unintended modifications.
2. **Function Factories**: Closures are often used to create functions dynamically based on certain parameters or configurations, allowing for the creation of reusable and customizable functions.
3. **Callback Functions**: Closures are commonly used in callback functions, allowing them to retain access to variables from their parent scope, even when invoked later in an asynchronous context.

In summary, closures are a powerful feature of JavaScript that facilitate encapsulation, data privacy, and the creation of flexible and modular code structures. Understanding closures is essential for mastering JavaScript's functional programming paradigm and writing efficient and maintainable code.

### Writing Clean Code ****

**Use Descriptive Variable Names:**

Choose meaningful and descriptive names for variables, functions, and classes. This improves code readability and makes it easier for others (or your future self) to understand the purpose of each component.

```jsx
// Bad Example
const x = 10;
function abc(a, b) {
  // code...
}

// Good Example
const defaultAge = 18;
function calculateArea(length, width) {
  // code...
}
```

### **2. Follow Consistent Formatting and Indentation:**

Consistent formatting and indentation make your code visually appealing and easier to navigate. Choose a consistent coding style and stick to it throughout your project.

```jsx
// Bad Example
const sum=function(a,b){
return a+b;
}

// Good Example
function sum(a, b) {
  return a + b;
}
```

### **3. Use Comments Wisely:**

Comments should explain why something is done, not what is done (assuming the code is clear enough). Over-commenting can clutter the codebase, while under-commenting can make it hard to understand.

```jsx
// Bad Example
// Add 1 to the counter
counter += 1;

// Good Example
// Increment the counter by 1
counter += 1;
```

### **4. Break Down Complex Functions:**

Avoid writing long and complex functions. Break them down into smaller, more manageable functions. Each function should ideally do one thing and do it well.

```jsx
// Bad Example
function processUserData(userData) {
  // 50 lines of code...
}

// Good Example
function getUserData() {
  // Code to fetch user data...
}

function processData(userData) {
  // Code to process user data...
}
```

### **5. Error Handling:**

Always handle errors gracefully. Use try-catch blocks to catch exceptions and handle them appropriately. This prevents unexpected crashes and improves the robustness of your code.

```jsx
try {
  // Code that may throw an error
} catch (error) {
  // Handle the error
  console.error(error);
}
```

### **6. Avoid Global Variables:**

Minimize the use of global variables as they can lead to naming conflicts and make it hard to track the flow of data. Instead, encapsulate your code in modules and use proper scoping

```jsx
// Bad Example
let total = 0;

function addToTotal(value) {
  total += value;
}

// Good Example
function calculateTotal() {
  let total = 0;

  function addToTotal(value) {
    total += value;
  }

  // Code to calculate total...
}
```

### **7. Use ES6 Features:**

Take advantage of modern JavaScript features provided by ES6 and beyond. Features like arrow functions, template literals, destructuring, and classes can make your code more concise and expressive.

```jsx
// Before ES6
function greet(name) {
  return 'Hello, ' + name + '!';
}

// With ES6
const greet = (name) => `Hello, ${name}!`;
```

### **8. Testing and Refactoring:**

Regularly test your code and refactor it as needed. Testing ensures that your code behaves as expected, while refactoring keeps it clean and maintainable over time.

```jsx
// Bad Example (Unrefactored)
function calculateTotal(price, quantity) {
  let total = price * quantity;
  total = applyDiscount(total);
  return total;
}

// Good Example (Refactored)
function calculateTotal(price, quantity) {
  const subtotal = price * quantity;
  return applyDiscount(subtotal);
}
```

### **Document Object Model (DOM) in JavaScript:**

The Document Object Model (DOM) is a programming interface for web documents. It represents the structure of HTML and XML documents as a tree-like structure, where each node represents a part of the document, such as elements, attributes, and text. JavaScript interacts with the DOM to dynamically update and modify the content, structure, and style of web pages.

### Understanding the DOM Tree:

The DOM tree consists of several types of nodes:

1. **Document Node**: Represents the entire HTML document.
2. **Element Nodes**: Represent HTML elements.
3. **Attribute Nodes**: Represent attributes of elements.
4. **Text Nodes**: Represent text within elements.
5. **Comment Nodes**: Represent comments in the HTML.

### **Accessing DOM Elements:**

JavaScript provides several methods to access and manipulate DOM elements:

### 1. By ID:

You can access an element using its unique ID attribute.

```html
htmlCopy code
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>DOM Example</title>
</head>
<body>
    <div id="myDiv">Hello, world!</div>

    <script>
        // Accessing element by ID
        const myDiv = document.getElementById('myDiv');
        console.log(myDiv.textContent); // Output: Hello, world!
    </script>
</body>
</html>

```

### 2. By Class Name:

You can access elements by their class name using **`getElementsByClassName()`**.

```html
htmlCopy code
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>DOM Example</title>
</head>
<body>
    <div class="container">
        <p>Hello, world!</p>
    </div>

    <script>
        // Accessing elements by class name
        const containers = document.getElementsByClassName('container');
        console.log(containers.length); // Output: 1
    </script>
</body>
</html>

```

### 3. By Tag Name:

You can access elements by their tag name using **`getElementsByTagName()`**.

```html
htmlCopy code
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>DOM Example</title>
</head>
<body>
    <ul>
        <li>Item 1</li>
        <li>Item 2</li>
    </ul>

    <script>
        // Accessing elements by tag name
        const listItems = document.getElementsByTagName('li');
        console.log(listItems.length); // Output: 2
    </script>
</body>
</html>

```

### 4. By CSS Selector:

You can use **`querySelector()`** and **`querySelectorAll()`** to select elements using CSS selectors.

```html
htmlCopy code
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>DOM Example</title>
</head>
<body>
    <div class="container">
        <p>Hello, world!</p>
    </div>

    <script>
        // Accessing elements by CSS selector
        const paragraph = document.querySelector('.container p');
        console.log(paragraph.textContent); // Output: Hello, world!
    </script>
</body>
</html>

```

### **Manipulating DOM Elements:**

You can modify the content, attributes, and styles of DOM elements using JavaScript.

```html
htmlCopy code
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>DOM Example</title>
    <style>
        .highlight {
            color: red;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="myDiv">Hello, world!</div>

    <button onclick="changeText()">Change Text</button>

    <script>
        function changeText() {
            const myDiv = document.getElementById('myDiv');
            myDiv.textContent = 'Goodbye, world!';
            myDiv.classList.add('highlight');
        }
    </script>
</body>
</html>

```

This example demonstrates how to change the text content of an element and apply CSS styles dynamically. When the button is clicked, the text content of the **`<div>`** element is changed to "Goodbye, world!" and the **`.highlight`** class is added, making the text red and bold.

Manipulating the Document Object Model (DOM) in JavaScript is a fundamental aspect of web development. The DOM represents the structure of an HTML document as a tree-like data structure, where each node corresponds to an element in the document, such as paragraphs, headings, images, forms, etc. Manipulating the DOM dynamically alters this structure, allowing developers to create interactive and responsive web applications.

### **Understanding the DOM:**

The DOM is essentially an interface that enables scripts (like JavaScript) to dynamically access and modify the content, structure, and style of HTML documents. It provides a way for scripts to interact with the web page after it has been loaded into the browser.

### Basic DOM Elements:

Each HTML element in a document corresponds to a node in the DOM tree. These nodes can be accessed, modified, and manipulated using JavaScript.

### Accessing DOM Elements:

JavaScript provides several methods for accessing DOM elements:

1. **getElementById()**: Retrieves an element by its ID attribute.

```jsx
javascriptCopy code
const element = document.getElementById('myElement');

```

1. **getElementsByClassName()**: Retrieves elements by their class name.

```jsx
javascriptCopy code
const elements = document.getElementsByClassName('myClass');

```

1. **getElementsByTagName()**: Retrieves elements by their tag name.

```jsx
javascriptCopy code
const elements = document.getElementsByTagName('div');

```

1. **querySelector() / querySelectorAll()**: Retrieves elements using CSS selector syntax.

```jsx
javascriptCopy code
const element = document.querySelector('#myElement');
const elements = document.querySelectorAll('.myClass');

```

### **Manipulating DOM Elements:**

Once you have accessed DOM elements, you can manipulate them in various ways:

### Changing Content:

You can change the content of an element using properties like **`innerHTML`**, **`textContent`**, or **`innerText`**.

```jsx
javascriptCopy code
const element = document.getElementById('myElement');
element.innerHTML = '<b>New content</b>';

```

### Modifying Attributes:

You can modify HTML attributes of elements using JavaScript.

```jsx
javascriptCopy code
const element = document.getElementById('myElement');
element.setAttribute('class', 'newClass');

```

### Creating New Elements:

You can dynamically create new elements and append them to the DOM.

```jsx
javascriptCopy code
const newElement = document.createElement('div');
newElement.textContent = 'New Element';
document.body.appendChild(newElement);

```

### Event Handling:

You can attach event listeners to DOM elements to handle user interactions.

```jsx
javascriptCopy code
const button = document.getElementById('myButton');
button.addEventListener('click', function() {
    console.log('Button clicked!');
});

```

### **Event Listeners in JavaScript:**

Event listeners in JavaScript are crucial for building interactive and responsive web applications. They allow developers to attach functions (event handlers) to specific events that occur in the browser, such as user actions (e.g., clicks, keypresses, mouse movements) or changes in the document (e.g., loading, resizing).

### How Event Listeners Work:

1. **Event Registration**: To respond to events, developers register event listeners on HTML elements or specific targets in the Document Object Model (DOM).
2. **Event Handling**: When the specified event occurs, the associated event listener executes the callback function, allowing developers to respond to the event appropriately.

### Example Code:

Let's consider a simple example where we attach event listeners to a button element to respond to user clicks.

HTML:

```html
htmlCopy code
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Event Listeners Example</title>
</head>
<body>
  <button id="myButton">Click Me!</button>
  <script src="script.js"></script>
</body>
</html>

```

JavaScript (**`script.js`**):

```jsx
javascriptCopy code
// Get reference to the button element
const button = document.getElementById('myButton');

// Define event handler function
function handleClick(event) {
  console.log('Button clicked!');
  console.log('Event details:', event);
}

// Attach event listener to the button element
button.addEventListener('click', handleClick);

```

In this example:

- We retrieve a reference to the button element using **`document.getElementById('myButton')`**.
- We define a function **`handleClick(event)`** that logs a message to the console when the button is clicked. The **`event`** parameter contains information about the event.
- We attach an event listener to the button using **`addEventListener()`**. The first argument is the event type (**`'click'`**), and the second argument is the event handler function (**`handleClick`**).

Now, whenever the button is clicked, the **`handleClick`** function will be called, and the message "Button clicked!" along with event details will be logged to the console.